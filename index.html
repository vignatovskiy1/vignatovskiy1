<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>FortiEDR Incident Summary Formatter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      color-scheme: light dark;
      --bg: #f5f6f8;
      --fg: #1f2933;
      --card: #ffffff;
      --accent: #2563eb;
      --muted: #4b5563;
      --border: rgba(15, 23, 42, 0.12);
      font-family: "Inter", system-ui, -apple-system, "Segoe UI", sans-serif;
      line-height: 1.6;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #0f172a;
        --fg: #e2e8f0;
        --card: rgba(15, 23, 42, 0.9);
        --muted: #94a3b8;
        --border: rgba(148, 163, 184, 0.2);
      }
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      display: flex;
      justify-content: center;
      padding: 2.5rem 1rem;
      min-height: 100vh;
    }

    main {
      width: min(960px, 100%);
    }

    .card {
      background: var(--card);
      border-radius: 18px;
      padding: clamp(1.5rem, 2vw + 1rem, 2.75rem);
      box-shadow: 0 22px 65px rgba(15, 23, 42, 0.12);
      border: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 1.75rem;
    }

    h1 {
      margin: 0;
      font-size: clamp(1.8rem, 2.5vw + 1.2rem, 2.6rem);
      letter-spacing: -0.01em;
    }

    p {
      margin: 0;
      color: var(--muted);
      max-width: 60ch;
    }

    label {
      font-weight: 600;
      display: inline-block;
      margin-bottom: 0.5rem;
    }

    textarea {
      width: 100%;
      min-height: 220px;
      resize: vertical;
      border-radius: 14px;
      border: 1px solid var(--border);
      padding: 1rem;
      font: 1rem/1.5 "JetBrains Mono", "Fira Code", monospace;
      background: rgba(15, 23, 42, 0.04);
      color: inherit;
    }

    textarea:focus {
      outline: 3px solid rgba(37, 99, 235, 0.25);
      border-color: rgba(37, 99, 235, 0.45);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 0.65rem 1.4rem;
      font-weight: 600;
      font-size: 0.95rem;
      cursor: pointer;
      transition: transform 0.18s ease, box-shadow 0.18s ease, background 0.18s ease;
    }

    button.primary {
      background: var(--accent);
      color: #fff;
      box-shadow: 0 12px 24px rgba(37, 99, 235, 0.25);
    }

    button.secondary {
      background: rgba(148, 163, 184, 0.18);
      color: inherit;
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.6;
      box-shadow: none;
    }

    button:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 28px rgba(15, 23, 42, 0.18);
    }

    #message {
      font-weight: 600;
      color: var(--muted);
    }

    .results {
      display: grid;
      gap: 1.5rem;
    }

    .event-card {
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 1.25rem;
      background: rgba(15, 23, 42, 0.04);
    }

    @media (prefers-color-scheme: dark) {
      .event-card {
        background: rgba(148, 163, 184, 0.08);
      }
    }

    .event-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      margin-bottom: 0.75rem;
    }

    .event-title {
      font-weight: 700;
    }

    .event-actions {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .event-actions button {
      padding: 0.4rem 0.9rem;
      font-size: 0.85rem;
      border-radius: 10px;
    }

    pre {
      margin: 0;
      border-radius: 12px;
      padding: 1.25rem;
      background: #0f172a;
      color: #e2e8f0;
      overflow-x: auto;
      font-family: "JetBrains Mono", "Fira Code", "SFMono-Regular", Consolas, monospace;
      font-size: 0.92rem;
      line-height: 1.6;
    }

    @media (prefers-color-scheme: light) {
      pre {
        background: #10172a;
        color: #f8fafc;
      }
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      border: 0;
    }
  </style>
</head>
<body>
  <main>
    <section class="card" aria-labelledby="page-title">
      <div>
        <h1 id="page-title">FortiEDR Incident Summary Formatter</h1>
        <p>Paste FortiEDR events, then format them into analyst-ready incident summaries with perfectly aligned layout.</p>
      </div>

      <div>
        <label for="rawInput">Raw FortiEDR events</label>
        <textarea id="rawInput" placeholder="Paste FortiEDR events hereâ€¦" aria-describedby="input-help"></textarea>
        <p id="input-help" class="sr-only">Use the Format Events button to parse the pasted events into summaries.</p>
      </div>

      <div class="controls" role="group" aria-label="Formatting controls">
        <button id="formatButton" class="primary" type="button">Format Events</button>
        <button id="copyAllButton" class="secondary" type="button" disabled>Copy All</button>
        <button id="clearButton" class="secondary" type="button">Clear</button>
      </div>

      <div id="message" role="status" aria-live="polite"></div>

      <div id="results" class="results" aria-live="polite"></div>
    </section>
  </main>

  <script>
    const rawInput = document.getElementById('rawInput');
    const formatButton = document.getElementById('formatButton');
    const copyAllButton = document.getElementById('copyAllButton');
    const clearButton = document.getElementById('clearButton');
    const resultsEl = document.getElementById('results');
    const messageEl = document.getElementById('message');

    let formattedEvents = [];

    function normalizeLineEndings(text) {
      return text.replace(/\r\n?/g, '\n');
    }

    function hasContent(text) {
      return /\S/.test(text);
    }

    function cleanValue(raw) {
      if (typeof raw !== 'string') return '';
      return raw.replace(/^[ \t]+/, '').replace(/[ \t]+$/, '');
    }

    function extractTableValue(lines, label) {
      const pattern = new RegExp('^' + label + '\\b', 'i');
      for (let i = 0; i < lines.length; i++) {
        if (pattern.test(lines[i])) {
          const after = lines[i].replace(pattern, '');
          const value = cleanValue(after.replace(/^[\s|:;-]+/, ''));
          if (value) return value;
          if (i + 1 < lines.length) {
            const next = cleanValue(lines[i + 1]);
            if (next) return next;
          }
        }
      }
      return '';
    }

    function stripDomain(user) {
      if (!user) return '';
      const raw = user.trim();
      if (!raw) return '';
      const parts = raw.split(/\\|\//);
      return parts[parts.length - 1];
    }

    function extractEventIdAndProcess(lines, usedEventIds) {
      const eventPattern = /\bEvent\s+(\d{6,})\b/i;
      const candidates = [];

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const eventMatch = line.match(eventPattern);
        if (eventMatch) {
          candidates.push({
            id: eventMatch[1],
            index: i,
            matchText: eventMatch[0],
            matchIndex: eventMatch.index ?? line.indexOf(eventMatch[0])
          });
        }
      }

      if (!candidates.length) {
        return { eventId: '', processName: '' };
      }

      let selected = null;
      for (const candidate of candidates) {
        if (!usedEventIds || !usedEventIds.has(candidate.id)) {
          selected = candidate;
          break;
        }
      }

      if (!selected) {
        selected = candidates[0];
      }

      let processName = '';
      const lineWithEvent = lines[selected.index];
      if (selected.matchIndex > -1) {
        const remainder = lineWithEvent.slice(selected.matchIndex + selected.matchText.length);
        const processMatch = remainder.match(/([A-Za-z0-9_.-]+\.(?:exe|dll|msi|bat|cmd|ps1|scr|com))/i);
        if (processMatch) {
          processName = processMatch[1];
        }
      }

      if (!processName) {
        for (let i = selected.index + 1; i < lines.length; i++) {
          const candidateLine = cleanValue(lines[i]);
          if (!candidateLine) continue;

          const nextMatch = candidateLine.match(eventPattern);
          if (nextMatch) {
            if (nextMatch[1] === selected.id) {
              continue;
            }
            break;
          }

          const exeMatch = candidateLine.match(/([A-Za-z0-9_.-]+\.(?:exe|dll|msi|bat|cmd|ps1|scr|com))/i);
          processName = exeMatch ? exeMatch[1] : candidateLine;
          break;
        }
      }

      processName = cleanValue(processName.replace(/^Process\s*[:|\-]*/i, ''));

      return { eventId: selected.id, processName };
    }

    function extractProcessFallback(text) {
      const tableMatch = text.match(/^PROCESS\s*[|:;-]*\s*([^\r\n]+)/im);
      if (tableMatch) {
        const cleaned = cleanValue(tableMatch[1]);
        if (cleaned) return cleaned;
      }
      const loneExe = text.match(/^\s*([\w.-]+\.exe)\s*$/im);
      return loneExe ? loneExe[1] : '';
    }

    function extractCollectorGroup(text, lines) {
      const direct = extractLineValue(text, 'Collector groups?', true);
      if (direct) return direct;
      const triggered = text.match(/Triggered Rules[^\r\n]*?([A-Za-z0-9][A-Za-z0-9 _-]{0,40})/i);
      if (triggered) {
        const candidate = cleanValue(triggered[1]).split(/[:\-]/)[0].trim();
        if (candidate) return candidate;
      }
      for (const line of lines) {
        if (/Collector Group/i.test(line)) {
          if (/Default/i.test(line)) {
            return 'Default';
          }
          const value = cleanValue(line.split(/Collector Group/i)[1]);
          if (value) return value;
        }
      }
      for (const line of lines) {
        if (/Default/i.test(line) && /Collector/i.test(line)) {
          return 'Default';
        }
      }
      return 'Default';
    }

    function extractLineValue(text, label, allowNextLine = false) {
      const regex = new RegExp('^' + label + '\\s*:?[ \\t]*([^\\r\\n]*)$', 'im');
      const match = text.match(regex);
      if (!match) return '';
      let value = match[1];
      if (value === undefined) value = '';
      if (!hasContent(value) && allowNextLine) {
        const normalized = normalizeLineEndings(text);
        const lines = normalized.split('\n');
        const labelPattern = new RegExp('^' + label + '\\s*:?','i');
        let index = -1;
        for (let i = 0; i < lines.length; i++) {
          if (labelPattern.test(lines[i])) {
            index = i;
            break;
          }
        }
        if (index > -1) {
          for (let i = index + 1; i < lines.length; i++) {
            const candidate = lines[i];
            if (!hasContent(candidate)) continue;
            const trimmed = candidate.trim();
            if (/^[A-Z][A-Za-z0-9 ()/\-]{1,40}:/.test(trimmed)) {
              break;
            }
            const indicators = ['Event', 'Device', 'Process', 'Target', 'Command Line', 'User', 'Company', 'Certificate', 'Classification', 'Collector', 'Triggered', 'Destination', 'DESTINATION', 'Action', 'History', 'Details', 'Policy', 'Rule', 'Count'];
            if (indicators.some(indicator => trimmed.toLowerCase().startsWith(indicator.toLowerCase()))) {
              break;
            }
            value = candidate;
            break;
          }
        }
      }
      return cleanValue(value);
    }

    function extractClassification(text) {
      const classifications = [];
      const regex = /^Classification(?: Details| History)?[^:\n]*[:\-]?\s*(.+)$/gim;
      let match;
      while ((match = regex.exec(text)) !== null) {
        const entry = cleanValue(match[1]);
        if (entry) {
          const parts = entry.split(' - ');
          classifications.push(parts.pop());
        }
      }
      if (classifications.length) {
        return classifications[classifications.length - 1];
      }
      const statusRegex = /(Likely Safe|Safe|Inconclusive|Malicious|Likely Malicious|Suspicious|Unsafe|Unknown|Malicious Attempt)/gi;
      const statuses = [];
      let statusMatch;
      while ((statusMatch = statusRegex.exec(text)) !== null) {
        statuses.push(statusMatch[1]);
      }
      return statuses.length ? statuses[statuses.length - 1] : 'Unknown';
    }

    function extractCertification(text) {
      const certLine = extractLineValue(text, 'Certificate');
      if (certLine) return certLine;
      const signedMatch = text.match(/\b(Signed|Unsigned|Not Signed|No Signed)\b/i);
      return signedMatch ? signedMatch[1].replace(/Not/i, 'Unsigned') : 'N/A';
    }

    function extractAdditionalInfo(text, lines) {
      for (let i = 0; i < lines.length; i++) {
        if (/^DESTINATION\b/i.test(lines[i].trim())) {
          const after = cleanValue(lines[i].replace(/^DESTINATION\b/i, '').replace(/^[\s|:;-]+/, ''));
          if (after) return after;
          for (let j = i + 1; j < Math.min(lines.length, i + 3); j++) {
            const next = cleanValue(lines[j]);
            if (next) return next;
          }
        }
      }
      const actionMatch = text.match(/\b(File Rename Attempt|Service Access|Process Access|File Access|Registry Access|Network Access|File Modification Attempt|File Creation Attempt|Execution Attempt|PowerShell Execution)\b/i);
      if (actionMatch) return actionMatch[1];
      const triggeredLineIndex = lines.findIndex(line => /Triggered Rules/i.test(line));
      if (triggeredLineIndex > -1) {
        for (let i = triggeredLineIndex + 1; i < lines.length; i++) {
          const candidate = cleanValue(lines[i]);
          if (candidate) {
            return candidate.split(/[:\-]/)[0].trim();
          }
        }
      }
      return 'N/A';
    }

    function extractDeviceFromLastSeen(lines) {
      for (let i = 0; i < lines.length; i++) {
        if (/LAST SEEN/i.test(lines[i])) {
          for (let j = i + 1; j < lines.length; j++) {
            const candidate = cleanValue(lines[j].replace(/^[\s|:;-]+/, ''));
            if (!candidate) continue;
            if (/^(Event\s+\d{6,}|Device\b|Process\b|Target\b|Command Line\b|User\b|Company\b|Collector\b|Classification\b|Additional information\b)/i.test(candidate)) {
              break;
            }
            return candidate;
          }
        }
      }
      return '';
    }

    function extractUser(lines) {
      for (let i = 0; i < lines.length; i++) {
        const match = lines[i].match(/^User\s*:?[ \t]*(.*)$/i);
        if (!match) continue;

        const inlineValue = cleanValue(match[1]);
        if (inlineValue) {
          return inlineValue;
        }

        for (let j = i + 1; j < lines.length; j++) {
          const candidate = cleanValue(lines[j]);
          if (!candidate) continue;
          if (/^(Count|Company|Collector|Classification|Command Line|Target|Device|Process|Event|Certificate|Additional information|Triggered|Destination|Policy|Rule|History|Details)\b/i.test(candidate)) {
            break;
          }
          return candidate;
        }
        break;
      }
      return '';
    }

    function extractProcessFromLastSeen(lines) {
      for (let i = 0; i < lines.length; i++) {
        if (/LAST SEEN/i.test(lines[i])) {
          const following = [];
          for (let j = i + 1; j < lines.length && following.length < 8; j++) {
            const candidate = cleanValue(lines[j]);
            if (!candidate) continue;
            following.push(candidate);
          }
          if (following.length >= 3) {
            for (let k = 2; k < following.length; k++) {
              let value = following[k];
              if (/^Process\s*:?-?\s*$/i.test(value)) {
                if (k + 1 < following.length) {
                  value = following[++k];
                } else {
                  continue;
                }
              }
              if (/^(Collector groups?|User|Company|Command Line|Target|Classification|Additional information|Certificate)/i.test(value)) {
                continue;
              }
              return cleanValue(value.replace(/^Process\s*[:|\-]*/i, ''));
            }
          }
        }
      }
      return '';
    }

    function parseEvent(chunk, usedEventIds) {
      const normalized = normalizeLineEndings(chunk);
      const lines = normalized.split('\n');
      const { eventId, processName } = extractEventIdAndProcess(lines, usedEventIds);
      if (eventId && usedEventIds) {
        usedEventIds.add(eventId);
      }
      const processFromLastSeen = extractProcessFromLastSeen(lines);
      const process = processFromLastSeen || processName || extractProcessFallback(normalized) || 'N/A';
      const collectorGroup = extractCollectorGroup(normalized, lines) || 'Default';
      const device = extractDeviceFromLastSeen(lines) || extractTableValue(lines, 'DEVICE') || 'N/A';
      const userRaw = extractUser(lines) || extractLineValue(normalized, 'User', true);
      const user = stripDomain(userRaw) || 'N/A';
      const company = extractLineValue(normalized, 'Company', true) || 'N/A';
      const certification = extractCertification(normalized);
      const classification = extractClassification(normalized);
      const targetLine = extractLineValue(normalized, 'Target', true) || 'N/A';
      const commandLineRaw = extractLineValue(normalized, 'Command Line', true);
      const commandLine = hasContent(commandLineRaw) ? commandLineRaw : 'N/A';
      const additionalInfo = extractAdditionalInfo(normalized, lines);

      return {
        eventId: eventId || 'N/A',
        process,
        collectorGroup,
        device,
        user,
        company,
        certification,
        classification: classification || 'Unknown',
        target: targetLine,
        commandLine,
        additionalInfo
      };
    }

    function renderEvent(event, index) {
      const template = [
        `Event ID:                  ${event.eventId}`,
        `Process:                   ${event.process}`,
        `Collector Group:      ${event.collectorGroup}`,
        `Device:                     ${event.device}`,
        `Logged-in User:       ${event.user}`,
        `Company:                ${event.company}`,
        `Certification:            ${event.certification}`,
        `Classification:           ${event.classification}`,
        `Virus Total link:     N/A`,
        '',
        '',
        `Target: ${event.target}`,
        '',
        '',
        `Command Line: ${event.commandLine}`,
        '',
        '',
        `Additional information: ${event.additionalInfo}`,
        '',
        '',
        `Tech notes: `,
        '',
        '',
        `Next Steps:`,
        `Please advise on actions you would like LNX to take on this FortiEDR event notification. If no response is given, we will mark as Unsafe and BLOCK.`,
        `-----------------------------------------------------------------------------------------------`
      ].join('\n');

      const wrapper = document.createElement('article');
      wrapper.className = 'event-card';

      const header = document.createElement('div');
      header.className = 'event-header';

      const title = document.createElement('span');
      title.className = 'event-title';
      title.textContent = `Event ${index + 1}`;

      const actions = document.createElement('div');
      actions.className = 'event-actions';

      const copyButton = document.createElement('button');
      copyButton.type = 'button';
      copyButton.className = 'secondary';
      copyButton.textContent = 'Copy';
      copyButton.addEventListener('click', () => copyToClipboard(template));

      actions.appendChild(copyButton);
      header.append(title, actions);

      const pre = document.createElement('pre');
      pre.textContent = template;

      wrapper.append(header, pre);
      resultsEl.appendChild(wrapper);

      return template;
    }

    async function copyToClipboard(text) {
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
        } else {
          const textarea = document.createElement('textarea');
          textarea.value = text;
          textarea.setAttribute('readonly', '');
          textarea.style.position = 'absolute';
          textarea.style.left = '-9999px';
          document.body.appendChild(textarea);
          textarea.select();
          document.execCommand('copy');
          document.body.removeChild(textarea);
        }
        messageEl.textContent = 'Copied to clipboard.';
      } catch (error) {
        console.error('Clipboard copy failed', error);
        messageEl.textContent = 'Unable to copy to clipboard.';
      }
    }

    function formatEvents() {
      const rawText = rawInput.value;
      if (!hasContent(rawText)) {
        messageEl.textContent = 'Please paste FortiEDR events first.';
        resultsEl.innerHTML = '';
        formattedEvents = [];
        copyAllButton.disabled = true;
        return;
      }

      const normalized = normalizeLineEndings(rawText);
      const parts = normalized.split(/Event GraphAutomated Analysis/g);
      const events = [];

      const usedEventIds = new Set();

      for (const part of parts) {
        if (!hasContent(part)) continue;
        const event = parseEvent(part, usedEventIds);
        events.push(event);
      }

      resultsEl.innerHTML = '';
      formattedEvents = [];

      if (!events.length) {
        messageEl.textContent = 'No events were detected. Check the delimiter and try again.';
        copyAllButton.disabled = true;
        return;
      }

      events.forEach((event, index) => {
        const formatted = renderEvent(event, index);
        formattedEvents.push(formatted);
      });

      messageEl.textContent = `${events.length} event${events.length === 1 ? '' : 's'} formatted.`;
      copyAllButton.disabled = false;
    }

    function copyAll() {
      if (!formattedEvents.length) return;
      const joined = formattedEvents.join('\n');
      copyToClipboard(joined);
    }

    function clearAll() {
      rawInput.value = '';
      resultsEl.innerHTML = '';
      formattedEvents = [];
      messageEl.textContent = '';
      copyAllButton.disabled = true;
      rawInput.focus();
    }

    formatButton.addEventListener('click', formatEvents);
    copyAllButton.addEventListener('click', copyAll);
    clearButton.addEventListener('click', clearAll);
  </script>
</body>
</html>
